# props:父组件传递 数字、true/false,

<!-- 仅写上 prop 但不传值，会隐式转换为 `true` -->
<BlogPost is-published />
<!-- 虽然 `false` 是静态的值，我们还是需要使用 v-bind -->
<!-- 因为这是一个 JavaScript 表达式而不是一个字符串 -->
<BlogPost :is-published="false" />
<!-- 根据一个变量的值动态传入 -->
<BlogPost :is-published="post.isPublished" />

# 子组件监听父组件传递动态值

父：传递isOPen 初始化子组件 view
<Child :parent="isOPen" @child="listenChild" @cpCl="listenCp" />

 <script>
    //...省略...
    function listenCp(data) {//监听子组件弹框关闭
        isOPen.value = data.value
    }
    //...省略...
 </script>

子：
<el-dialog title='子组件' v-model="cpView" @close="cpClose">

<script>
    //...省略...
    setup(props,ctx){
    let cpView = ref(66)//初始化 cpView 为false
    watch(() => props.parent, (newValue) => {//v3监听父组件传的动态值
                cpView.value = newValue
            }, { immediate: true, deep: true })
    }
    //如果是弹框组件在关闭前得要通知父组件改变 isOPen 值
    function cpClose() {
            ctx.emit('cpCl', ref(false))
            cpView.value = false
            console.log(66)
        }
    //...省略...
</script>

# cesium 本身没有自动生成的id 使用最简单的办法之一是使用 JavaScript 的 Date.now() 和 Math.random()

使用 CallbackProperty 动态更新矩形的几何形状的确可以减少性能消耗，因为它避免了在每次鼠标移动时创建和删除实体。然而，在这种情况下，使用 Primitive 可能会更高效，因为 Primitive 是低级图形元素，处理性能通常比 Entity 更好

# axios异步

async mounted() {
try {
const response = await axios.get('/users/1');
this.user = response.data;
} catch (error) {
console.error('There was an error!', error);
this.error = '获取用户数据失败';
}
}

# nav控制

点击当前的菜单页面标记问true其余为false，替代以下
for (let i = 0; i < whichPage.length; i++) {
if (index \* 1 - 1 == i) {
whichPage[i][i + ''] = true
} else {
whichPage[i][i + ''] = false
}
}

# eslint google报错

出现此错误的'google' is not defined.eslintno-undef原因是 ESLint linter 无法识别googleGoogle Maps JavaScript API 提供的全局对象。要解决此问题，您可以更新 ESLint 配置以将其识别google为全局变量
.eslintrc.js  
globals: {
google: 'readonly',
},  
.eslintrc.json
"globals": {
"google": "readonly"
}

# axios传值

axios 会自动处理对象的 JSON 序列化，只要你设置正确的请求头 Content-Type。

# vue兄弟间传值

使用父组件作为中介：
父组件负责管理状态，并将状态通过 props 和事件传递给子组件。这种方法适用于简单的兄弟组件通信。（简单的）

使用 Vue 3 的提供/注入 (Provide/Inject) API：
这种方法允许祖先组件向其所有后代组件提供数据，而无需通过每一个中间组件显式地传递 props。（稍复杂的）

使用状态管理工具，例如 Vuex 或者 Pinia：
对于更复杂的应用，使用一个状态管理库可以使得状态管理更加集中和清晰（大型应用或复杂状态管理）

# 调试后端 postman 使用raw 选择JSON 调试

# 数组[1,2,3,4]要toString一下，不然json转不了（切记----），包含对象toString也不行

[{'lon': '121.531527','lat': '25.022567'},{'lon': '121.611206','lat': '25.022567'},{'lon': '121.611206','lat': '25.110498'},{'lon': '121.531527','lat': '25.110498'},{'lon': '121.531527','lat': '25.022567'}]

# 浏览器限制无法获取文件夹的绝对路径，只能通过选择的文件获取到相对路径

file.webkitRelativePath

# calc()

width:calc(100%-100px);无效是因为有两个原因：1、必须加上单位，2、必须在运算符左右用空格隔开，

# provide inject 数据初始化父传子没数据修改保存后有.

# cesium 绘点 PointPrimitive

var pointPrimitive = new Cesium.PointPrimitive({\*\*\*})
viewer.scene.primitives.add(pointPrimitive)
//报错--TypeError: primitives[i].update is not a function
//原因--创建一个点，并通过调用 PointPrimitiveCollection#add 来设置其初始属性。不要直接调用构造函数（ Cesium.PointPrimitive()）。

# vscode 自动格式化

format Document With 选择 prettier 格式
或：在设置中
"[vue]": {
// "editor.defaultFormatter": "octref.vetur",
"editor.defaultFormatter": "esbenp.prettier-vscode",
"editor.formatOnType": true,
"editor.formatOnSave": true,
}

# nvm https://github.com/coreybutler/nvm-windows/releases

nvm list available， 查看网络可以安装的版本
nvm install 14.14.0

# axios get请求参数中的[]没有被编码，报400错误

https://blog.csdn.net/P6P7qsW6ua47A2Sb/article/details/119465740
https://tools.ietf.org/html/rfc3986规范中提到URL只允许包含四种大类的字符（也称非保留字符）：
英文字母（a-zA-Z）
数字（0-9）
-\_.~ 4个特殊字符
保留字符，RFC3986中指定了保留字符（英文字符）为： ! \* ' ( ) ; : @ & = + $ , / ? # [ ]

# request 请求参数编译

编译：encodeURIComponent(originalText)
反编译：decodeURIComponent(encodedText)
数组参数：要单独JSON.stringfy(arr)

# const pointCollection = ref(null)//此定义集合右键删除不掉当前点击年份实体

这样才能删除（不明白）：
var pointCollection = viewer.scene.primitives.add(new Cesium.PointPrimitiveCollection())

# cesium 保存 primitive 颜色 right_tive.color = temp.color.clone()

# ctrl + shift + p 格式化json数据（一行显示）

# for 循环删除元素等倒序删除，因为数组长度在动态变化。

for (let i = arr.length - 1; i >= 0; i--) {
if (arr[i] === 0) {
arr.splice(i, 1);
}
}

# 矩形entity 也是一个 primitive primitives.removeAll()也会将存放矩形的集合删掉，下次再画矩形就会报错

# form 表单清空

<el-form ref="formRef">
    <el-form-item prop="indexValue" label="key值：">
        <el-input v-model="form.indexValue" />
    </el-form-item>
</el-form>
const formRef = ref(null)
const resetForm = () => {
    let form = unref(formRef)//这个是重要的一步
    form.resetFields()
}

# dialog 内容加载完成后再获取dom元素

@opened="onDialogOpened"
const onDialogOpened = () => {
nextTick(() => {
console.log('Dialog and Table are fully rendered');
// 在这里可以执行Dialog和Table渲染完成后的操作
});
};

# 清空上次筛选器中的值

tableRef.value.clearFilter('yearMonth');

# 判断是字符串还是对象（如果你想要检查 pick.id 是否是一个对象，可以使用 typeof 或 instanceof 来做更合适的检查）

let pick = { id: 'example' }; // 或 { id: { name: 'example' } }
if (typeof pick.id === 'string') {
console.log('pick.id 是一个字符串');
} else if (typeof pick.id === 'object' && pick.id !== null) {
console.log('pick.id 是一个对象');
} else {
console.log('pick.id 不是字符串也不是对象');
}

# 有点不理解

const menuItems = ref(initializeMenuItems());
// 使用 reactive 定义 manamenu 对象
const manamenu = reactive({
menuItems: menuItems.value,
initializeMenuItems() {
this.menuItems = initializeMenuItems();
}
});
manamenu.initializeMenuItems();
function toggleDsy(index) {
manamenu.menuItems[index].dsy = true;
}

manaRef.value.manamenu.initializeMenuItems()
manaRef.value.toggleDsy(0)

# 从0到1很难，从1到2也很难
